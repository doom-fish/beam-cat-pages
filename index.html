<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>beam.cat</title>
    <meta property="og:title" content="beam.cat">
    <meta property="og:image" content="https://beam.cat/og-image.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://beam.cat">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://beam.cat/og-image.png">
    <script>
        if (location.protocol === 'http:' && location.hostname !== 'localhost' && !location.hostname.startsWith('100.')) {
            location.replace('https://' + location.host + location.pathname);
        }
    </script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-user-select: none; }
        html, body { background: #000; overflow: hidden; height: 100%; }
        canvas { display: block; width: 100vw; height: 100vh; touch-action: none; }
        #sound-hint {
            position: fixed;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(200, 100, 255, 0.8);
            font-family: monospace;
            font-size: 14px;
            letter-spacing: 2px;
            text-transform: uppercase;
            animation: pulse 2s ease-in-out infinite;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(200, 100, 255, 0.5);
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="sound-hint">tap for sound</div>
    <script>
// Pyramid geometry
const pyramidVertices = (() => {
    const p = [
        [0, 1, 0],      // apex
        [-1, -1, -1],   // base front-left
        [1, -1, -1],    // base front-right
        [1, -1, 1],     // base back-right
        [-1, -1, 1]     // base back-left
    ];
    const edges = [
        [0, 1], [0, 2], [0, 3], [0, 4],  // apex to base
        [1, 2], [2, 3], [3, 4], [4, 1]   // base square
    ];
    const verts = [];
    for (const [i1, i2] of edges) {
        verts.push(...p[i1], ...p[i2]);
    }
    return new Float32Array(verts);
})();

const quadVertices = new Float32Array([-1,-1, 1,-1, -1,1, 1,-1, 1,1, -1,1]);

// Shaders
const OCTA_VS = `
attribute vec3 a_pos;
uniform float u_time;
uniform float u_aspect;
uniform float u_scale;
uniform float u_rotation;  // Accumulated rotation angle (controlled by BPM in JS)
uniform float u_touching;  // 1.0 if touching, 0.0 if not
uniform vec2 u_touch;  // Touch/mouse position (0-1)

// Quaternion multiplication
vec4 qmul(vec4 q1, vec4 q2) {
    return vec4(
        q1.w * q2.xyz + q2.w * q1.xyz + cross(q1.xyz, q2.xyz),
        q1.w * q2.w - dot(q1.xyz, q2.xyz)
    );
}

// Rotate vector by quaternion
vec3 qrot(vec4 q, vec3 v) {
    vec4 qc = vec4(-q.xyz, q.w);
    return qmul(qmul(q, vec4(v, 0.0)), qc).xyz;
}

// Create quaternion from axis-angle
vec4 qaxis(vec3 axis, float angle) {
    float ha = angle * 0.5;
    return vec4(axis * sin(ha), cos(ha));
}

// Slerp between two quaternions
vec4 qslerp(vec4 q1, vec4 q2, float t) {
    float d = dot(q1, q2);
    if (d < 0.0) { q2 = -q2; d = -d; }
    if (d > 0.9995) return normalize(mix(q1, q2, t));
    float theta = acos(d);
    float sintheta = sin(theta);
    return (q1 * sin((1.0 - t) * theta) + q2 * sin(t * theta)) / sintheta;
}

void main() {
    vec3 p = a_pos * u_scale * 2.5;
    
    // Base Y rotation (spin)
    vec4 spinQ = qaxis(vec3(0.0, 1.0, 0.0), u_rotation);
    p = qrot(spinQ, p);
    
    // LookAt: point pyramid apex toward finger position
    // Finger in 3D space: screen X/Y mapped to world, Z forward
    vec2 fingerScreen = (u_touch - 0.5) * 2.0;  // -1 to 1
    
    // Pyramid is at origin, finger is closer for more direct pointing
    // Y inverted because screen Y=0 is top
    vec3 fingerWorld = vec3(
        fingerScreen.x * u_aspect * 2.0,  // More direct pointing
        -fingerScreen.y * 2.0,
        2.0  // Finger closer to pyramid for steeper angle
    );
    
    // Direction from pyramid to finger
    vec3 lookDir = normalize(fingerWorld);
    
    // Pyramid default points UP (+Y), we want it to point at lookDir
    vec3 up = vec3(0.0, 1.0, 0.0);
    
    // Rotation axis = cross(up, lookDir)
    vec3 axis = cross(up, lookDir);
    float axisLen = length(axis);
    
    if (axisLen > 0.0001) {
        axis = axis / axisLen;  // normalize
        // Rotation angle from up to lookDir
        float angle = acos(clamp(dot(up, lookDir), -1.0, 1.0));
        // Apply rotation scaled by u_touching
        vec4 lookQ = qaxis(axis, angle * u_touching);
        p = qrot(lookQ, p);
    }
    
    float d = 8.0 - p.z * 0.3;
    vec2 proj = p.xy / d;
    proj.x /= u_aspect;
    
    gl_Position = vec4(proj, 0.0, 1.0);
}
`;

const OCTA_FS = `
precision mediump float;
uniform float u_flicker;
uniform float u_time;
void main() {
    vec3 col = vec3(0.8, 0.1, 1.0) * u_flicker;
    gl_FragColor = vec4(col, 1.0);
}
`;

const BLUR_VS = `
attribute vec2 a_pos;
varying vec2 v_uv;
void main() {
    gl_Position = vec4(a_pos, 0.0, 1.0);
    v_uv = a_pos * 0.5 + 0.5;
}
`;

const BLUR_FS = `
precision mediump float;
uniform sampler2D u_tex;
uniform vec2 u_dir;
uniform vec2 u_res;
varying vec2 v_uv;
void main() {
    vec2 px = 1.0 / u_res;
    vec4 col = vec4(0.0);
    col += texture2D(u_tex, v_uv - 6.0 * u_dir * px) * 0.006;
    col += texture2D(u_tex, v_uv - 5.0 * u_dir * px) * 0.018;
    col += texture2D(u_tex, v_uv - 4.0 * u_dir * px) * 0.045;
    col += texture2D(u_tex, v_uv - 3.0 * u_dir * px) * 0.090;
    col += texture2D(u_tex, v_uv - 2.0 * u_dir * px) * 0.140;
    col += texture2D(u_tex, v_uv - 1.0 * u_dir * px) * 0.175;
    col += texture2D(u_tex, v_uv) * 0.200;
    col += texture2D(u_tex, v_uv + 1.0 * u_dir * px) * 0.175;
    col += texture2D(u_tex, v_uv + 2.0 * u_dir * px) * 0.140;
    col += texture2D(u_tex, v_uv + 3.0 * u_dir * px) * 0.090;
    col += texture2D(u_tex, v_uv + 4.0 * u_dir * px) * 0.045;
    col += texture2D(u_tex, v_uv + 5.0 * u_dir * px) * 0.018;
    col += texture2D(u_tex, v_uv + 6.0 * u_dir * px) * 0.006;
    gl_FragColor = col;
}
`;

const COMP_VS = `
attribute vec2 a_pos;
varying vec2 v_uv;
void main() {
    gl_Position = vec4(a_pos, 0.0, 1.0);
    v_uv = a_pos * 0.5 + 0.5;
}
`;

const COMP_FS = `
precision mediump float;
uniform sampler2D u_orig;
uniform sampler2D u_blur;
uniform sampler2D u_logo;
uniform sampler2D u_bg;
uniform float u_time;
uniform float u_aspect;
uniform float u_logoAspect;
uniform float u_clickGlitch;
uniform float u_beatGlitch;  // Synced to drum pattern
uniform float u_leadIntensity;  // Lead pattern for logo glow
uniform vec2 u_touch;  // Touch position for particles
uniform float u_touching;  // 1.0 if touching
varying vec2 v_uv;

void main() {
    // Background with aspect ratio correction
    vec2 bgUV = v_uv;
    float texAspect = 2.0;
    float screenAspect = u_aspect;
    if (screenAspect > texAspect) {
        float scale = screenAspect / texAspect;
        bgUV.y = (bgUV.y - 0.5) / scale + 0.5;
    } else {
        float scale = texAspect / screenAspect;
        bgUV.x = (bgUV.x - 0.5) / scale + 0.5;
    }
    vec2 bgPix = floor(bgUV * 400.0) / 400.0;
    vec3 bg = texture2D(u_bg, bgPix).rgb;
    
    vec4 orig = texture2D(u_orig, v_uv);
    vec4 blur = texture2D(u_blur, v_uv);
    
    // Pyramid glitch - only on beat or click (no random)
    float pyramidGlitchActive = max(u_beatGlitch, u_clickGlitch * 1.5);
    
    // Random RGB split offsets
    float splitSeed = floor(u_time * 15.0);
    float splitRandX = (fract(sin(splitSeed * 127.1) * 43758.5) - 0.5) * 2.0;
    float splitRandY = (fract(sin(splitSeed * 269.5) * 43758.5) - 0.5) * 2.0;
    float splitRandX2 = (fract(sin(splitSeed * 419.2) * 43758.5) - 0.5) * 2.0;
    float splitRandY2 = (fract(sin(splitSeed * 531.7) * 43758.5) - 0.5) * 2.0;
    
    float splitAmount = 0.015 * pyramidGlitchActive + 0.025 * u_clickGlitch;  // Beat + click
    vec2 rOffset = vec2(splitRandX, splitRandY) * splitAmount;
    vec2 bOffset = vec2(splitRandX2, splitRandY2) * splitAmount;
    
    vec4 origR = texture2D(u_orig, v_uv + rOffset);
    vec4 origB = texture2D(u_orig, v_uv + bOffset);
    vec4 blurR = texture2D(u_blur, v_uv + rOffset * 2.0);
    vec4 blurB = texture2D(u_blur, v_uv + bOffset * 2.0);
    
    vec2 center = vec2(0.5, 0.5);
    vec2 uv = v_uv;
    uv.x = (uv.x - 0.5) * u_aspect + 0.5;
    float dist = length(uv - center);
    // Flicker synced to lead pattern
    float flicker = 0.7 + 0.3 * u_leadIntensity;
    float ambient = exp(-dist * dist * 4.0) * 0.6 * flicker;
    ambient = clamp(ambient, 0.0, 1.0);
    vec3 ambientColor = vec3(0.08, 0.005, 0.15) * ambient;
    
    vec3 core, glow;
    if (pyramidGlitchActive > 0.5) {
        core = vec3(origR.r, orig.g * 0.5, origB.b) * 1.5;
        glow = vec3(blurR.r, blur.g * 0.3, blurB.b);
    } else {
        core = orig.rgb * 1.5;
        glow = blur.rgb;
    }
    glow.r *= 0.8;
    glow.g *= 0.1;
    glow.b *= 1.5;
    // Blend bg with purple based on distance from center
    vec3 baseBg = mix(ambientColor, bg * 0.15, smoothstep(0.0, 0.6, dist));
    vec3 col = baseBg + core * 2.0 + glow * 8.0;
    
    // Logo
    float logoScale = 0.3;
    float logoHeight = logoScale / u_logoAspect;
    
    // Logo glitch only on beat or click (no random)
    float flickerActive = max(u_beatGlitch * 0.8, u_clickGlitch);
    
    float jitterSeed = floor(u_time * 30.0);
    vec2 logoJitter = vec2(
        (fract(sin(jitterSeed * 127.1) * 43758.5) - 0.5) * 0.01,
        (fract(sin(jitterSeed * 269.5) * 43758.5) - 0.5) * 0.008
    ) * flickerActive;
    
    // Click adds extra jitter - much stronger
    logoJitter += vec2(
        (fract(sin(u_time * 127.1) * 43758.5) - 0.5) * 0.05,
        (fract(sin(u_time * 269.5) * 43758.5) - 0.5) * 0.04
    ) * u_clickGlitch;
    
    // Subtle ambient glow pulse
    float glowPulse = 0.85 + 0.15 * sin(u_time * 1.5);
    
    // Occasional subtle scan line
    float scanLine = sin(u_time * 0.7) * 0.5 + 0.5;
    float scanY = fract(u_time * 0.15);
    float scan = smoothstep(scanY - 0.02, scanY, v_uv.y) * smoothstep(scanY + 0.02, scanY, v_uv.y) * 0.1;
    
    vec2 logoCenter = vec2(0.5, 0.47) + logoJitter;
    vec2 logoUV = (v_uv - logoCenter) / vec2(logoScale, logoHeight) + 0.5;
    logoUV.x = (logoUV.x - 0.5) * u_aspect + 0.5;
    logoUV.y = 1.0 - logoUV.y;
    
    float glitchTime = floor(u_time * 12.0);
    float glitchRand = fract(sin(glitchTime * 43.758) * 12345.6);
    float glitchActive = max(flickerActive * step(0.3, glitchRand), u_clickGlitch);
    
    // Mini glitches - small occasional displacement
    float miniGlitchSeed = floor(u_time * 3.0);
    float miniGlitchRand = fract(sin(miniGlitchSeed * 91.7) * 43758.5);
    float miniGlitch = step(0.85, miniGlitchRand) * (miniGlitchRand - 0.85) * 0.02;
    
    float sliceY = floor(logoUV.y * 16.0);
    float sliceRand = fract(sin(sliceY * 91.2 + glitchTime) * 43758.5);
    float sliceOffset = (sliceRand - 0.5) * 0.25 * flickerActive * step(0.4, sliceRand);
    
    vec2 glitchUV = logoUV;
    glitchUV.x += sliceOffset + miniGlitch;
    
    // Logo glow
    float logoGlow = 0.0;
    for (float ox = -2.0; ox <= 2.0; ox += 1.0) {
        for (float oy = -2.0; oy <= 2.0; oy += 1.0) {
            vec2 offset = vec2(ox * 0.02, oy * 0.02);
            vec2 sampleUV = glitchUV + offset;
            if (sampleUV.x >= 0.0 && sampleUV.x <= 1.0 && sampleUV.y >= 0.0 && sampleUV.y <= 1.0) {
                logoGlow += texture2D(u_logo, sampleUV).a * 0.03;
            }
        }
    }
    col += vec3(0.4, 0.02, 0.6) * logoGlow * 2.0;
    
    // Dust particles - form rotating donut ring around finger
    vec2 particleOrigin = vec2(0.5, 0.47);
    
    for (float i = 0.0; i < 60.0; i += 1.0) {
        float seed = fract(sin(i * 127.1) * 43758.5);
        float seed2 = fract(sin(i * 269.5) * 43758.5);
        float seed3 = fract(sin(i * 419.2) * 43758.5);
        
        // Dust lifetime
        float lifetime = 2.0 + seed * 3.0;
        float phase = fract((u_time + seed * 20.0) / lifetime);
        float fade = smoothstep(0.0, 0.1, phase) * smoothstep(1.0, 0.5, phase);
        
        // Start around logo area
        float logoScale = 0.35;
        float logoHeight = logoScale / u_logoAspect;
        vec2 spawnPos = vec2(
            particleOrigin.x + (seed - 0.5) * logoScale * 1.1 / u_aspect,
            particleOrigin.y + (seed2 - 0.5) * logoHeight * 1.0
        );
        
        // Donut ring - all particles at same radius, evenly spaced
        float ringRadius = 0.06;  // Fixed radius for clear ring
        float angleOffset = i * 6.283185 / 60.0;  // Evenly space 60 particles around circle
        float rotationSpeed = 2.0;  // All rotate together
        float angle = u_time * rotationSpeed + angleOffset;
        
        // Aspect-correct the ring to be circular on screen
        vec2 ringOffset = vec2(cos(angle) / u_aspect, sin(angle)) * ringRadius;
        // u_touch.y is screen coords (0=top, 1=bottom), shader UV has 0=bottom, 1=top
        // Offset up slightly so ring is more centered
        vec2 fingerPos = vec2(u_touch.x, 1.0 - u_touch.y + 0.05);
        vec2 fingerRingPos = fingerPos + ringOffset;
        
        // Gentle dust drift when not touching
        float turbulence = sin(u_time * 1.5 + seed * 10.0) * 0.012 * phase;
        float riseSpeed = phase * 0.06 * (0.3 + seed3 * 0.7);
        float spread = (seed - 0.5) * 0.03 * phase;
        vec2 logoPos = spawnPos + vec2(spread + turbulence, riseSpeed);
        
        // Distance from particle to finger - faster lerp when closer
        float distToFinger = length(logoPos - fingerPos);
        float lerpSpeed = mix(1.0, 3.0, 1.0 - clamp(distToFinger * 5.0, 0.0, 1.0));
        float adjustedTouching = clamp(u_touching * lerpSpeed, 0.0, 1.0);
        
        // Smooth lerp both directions - faster when near finger
        vec2 particlePos = mix(logoPos, fingerRingPos, adjustedTouching);
        
        // Bigger square pixels - aspect corrected
        float size = 0.002 + seed3 * 0.001;
        vec2 diff = abs(v_uv - particlePos);
        diff.x *= u_aspect;
        float particle = step(diff.x, size) * step(diff.y, size);
        
        // Brighter twinkle - more intense when touching
        float twinkle = 0.6 + 0.4 * fract(sin(u_time * 3.0 + i * 3.7) * 43758.5);
        twinkle = mix(twinkle, 0.9 + 0.1 * twinkle, u_touching);
        
        // Brighter purple/pink dust color
        vec3 dustColor = vec3(1.0, 0.6, 1.0);
        col += dustColor * particle * fade * twinkle * 0.4;
    }
    
    if (glitchUV.x >= 0.0 && glitchUV.x <= 1.0 && glitchUV.y >= 0.0 && glitchUV.y <= 1.0) {
        vec4 logo = texture2D(u_logo, glitchUV);
        float logoFlicker = mix(1.0, 0.92 + 0.08 * step(0.7, fract(sin(u_time * 43.0) * 12345.6)), flickerActive);
        vec3 laserColor = vec3(1.0, 0.6, 1.0) * logoFlicker * glowPulse;
        laserColor += scan * vec3(0.5, 0.2, 0.8);  // Add scan line tint
        if (glitchActive > 0.5) {
            vec4 logoR = texture2D(u_logo, glitchUV + vec2(0.03, 0.0));
            vec4 logoB = texture2D(u_logo, glitchUV - vec2(0.03, 0.0));
            laserColor = vec3(logoR.a * 1.0, logo.a * 0.5, logoB.a * 1.2) * logoFlicker;
            col = mix(col, laserColor, max(logo.a, max(logoR.a, logoB.a)));
        } else {
            col = mix(col, laserColor, logo.a);
        }
    }
    
    // RGB glitch post-process
    if (flickerActive > 0.5) {
        float glitchSeed = floor(u_time * 12.0);
        float glitchPause = step(0.6, fract(sin(glitchSeed * 91.7) * 43758.5));
        if (glitchPause < 0.5) {
            float rgbOffset = 0.008;
            vec3 colR = texture2D(u_orig, v_uv + vec2(rgbOffset, 0.0)).rgb + texture2D(u_blur, v_uv + vec2(rgbOffset, 0.0)).rgb * 6.0;
            vec3 colB = texture2D(u_orig, v_uv - vec2(rgbOffset, 0.0)).rgb + texture2D(u_blur, v_uv - vec2(rgbOffset, 0.0)).rgb * 6.0;
            col = vec3(colR.r, col.g * 0.5, colB.b);
        }
    }
    
    gl_FragColor = vec4(clamp(col, 0.0, 1.0), 1.0);
}
`;

// WebGL setup
const canvas = document.getElementById('canvas');
const gl = canvas.getContext('webgl', { antialias: false });

function createShader(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        return null;
    }
    return shader;
}

function createProgram(vs, fs) {
    const prog = gl.createProgram();
    gl.attachShader(prog, createShader(gl.VERTEX_SHADER, vs));
    gl.attachShader(prog, createShader(gl.FRAGMENT_SHADER, fs));
    gl.linkProgram(prog);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(prog));
        return null;
    }
    return prog;
}

function createTexture(w, h) {
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    return tex;
}

function createFBO(tex) {
    const fbo = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
    return fbo;
}

// Programs
const octaProg = createProgram(OCTA_VS, OCTA_FS);
const blurProg = createProgram(BLUR_VS, BLUR_FS);
const compProg = createProgram(COMP_VS, COMP_FS);

// Buffers
const pyramidBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, pyramidBuffer);
gl.bufferData(gl.ARRAY_BUFFER, pyramidVertices, gl.STATIC_DRAW);

const quadBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
gl.bufferData(gl.ARRAY_BUFFER, quadVertices, gl.STATIC_DRAW);

// Resize handling
let w, h, blurW, blurH;
let texOrig, texBlur1, texBlur2, fboOrig, fboBlur1, fboBlur2;

function resize() {
    w = canvas.width = window.innerWidth * devicePixelRatio;
    h = canvas.height = window.innerHeight * devicePixelRatio;
    blurW = Math.floor(w * 0.75);
    blurH = Math.floor(h * 0.75);
    
    texOrig = createTexture(blurW, blurH);
    texBlur1 = createTexture(blurW, blurH);
    texBlur2 = createTexture(blurW, blurH);
    fboOrig = createFBO(texOrig);
    fboBlur1 = createFBO(texBlur1);
    fboBlur2 = createFBO(texBlur2);
}
window.addEventListener('resize', resize);
resize();

// Load logo
const logoTex = gl.createTexture();
let logoAspect = 1;
const logoImg = new Image();
logoImg.crossOrigin = 'anonymous';
logoImg.onload = () => {
    logoAspect = logoImg.width / logoImg.height;
    gl.bindTexture(gl.TEXTURE_2D, logoTex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, logoImg);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
};
logoImg.src = 'logos/psychodrama.png';

// Load background
const bgTex = gl.createTexture();
const bgImg = new Image();
bgImg.crossOrigin = 'anonymous';
bgImg.onload = () => {
    gl.bindTexture(gl.TEXTURE_2D, bgTex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, bgImg);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
};
bgImg.src = 'bg.webp';

function hash(p) {
    const p3 = (p * 0.1031) % 1.0;
    return ((p3 + p3 * (p3 + 19.19)) * (p3 + p3 * (p3 + 19.19))) % 1.0;
}

// Audio setup - supersaw chord
let audioCtx = null;
let masterGain = null;
let oscillators = [];
let chordOscillators = [];
let leadFilters = [];
let glitchGain = null;
let noiseNode = null;
let audioStarted = false;
let clickGlitch = 0;
let beatGlitch = 0;  // Synced to beat
let glitchMode = 0;  // 0-3 based on grid position
let currentPatternIndex = 0;
let currentBpm = 140;
let currentOctave = 4;  // Touch Y controls octave (2, 4, 8)
let touchPos = { x: 0.5, y: 0.5 };  // Current touch/mouse position
let smoothTouchPos = { x: 0.5, y: 0.5 };  // Smoothly interpolated position
let isTouching = false;
let pyramidRotation = 0;  // Accumulated rotation angle
let lastFrameTime = 0;  // For delta time
let smoothTouching = 0;  // Smoothed touching state for camera tilt
let leadIntensity = 0;  // Current lead pattern intensity for glow sync

// Gate patterns - structured electronic patterns (less random, more mechanical)
const gatePatterns = [
    [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],  // Straight 16ths
    [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],  // Four on floor
    [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0],  // Double hit
    [1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0],  // SID arp classic
];

// Minor chords from D minor scale - sub bass octave
const minorChords = [
    [18.35, 21.83, 27.5, 36.71, 55],       // Dm: D0, F0, A0, D1, A1
    [13.75, 16.35, 20.60, 27.5, 41.20],    // Am: A-1, C0, E0, A0, E1
    [20.60, 24.5, 30.87, 41.20, 61.74],    // Em: E0, G0, B0, E1, B1
    [24.5, 29.14, 36.71, 49, 73.42],       // Gm: G0, Bb0, D1, G1, D2
    [15.43, 18.35, 23.12, 30.87, 46.25],   // Bm: B-1, D0, F#0, B0, F#1
];

function triggerClickGlitch() {
    clickGlitch = 1.0;
    triggerGlitchSound();
}

function handleInteraction(e, triggerGlitch, setTouching = true) {
    let x = 0.5, y = 0.5;
    if (e.touches && e.touches[0]) {
        x = e.touches[0].clientX / window.innerWidth;
        y = e.touches[0].clientY / window.innerHeight;
    } else if (e.clientX !== undefined) {
        x = e.clientX / window.innerWidth;
        y = e.clientY / window.innerHeight;
    }
    
    // Update touch position for pyramid rotation (only if we have valid coords)
    if (setTouching) {
        touchPos.x = x;
        touchPos.y = y;
        isTouching = true;
    }
    
    // Grid position determines effects (4x4 grid = 16 cells)
    const gridX = Math.floor(x * 4);
    const gridY = Math.floor(y * 4);
    const newGlitchMode = gridX + gridY * 4;
    if (newGlitchMode !== glitchMode) {
        glitchMode = newGlitchMode;
        clickGlitch = 0.8;  // Trigger glitch on cell change
    }
    
    // Jam controls based on 4x4 grid
    if (window.jamState) {
        // X = chord (4 chords across screen)
        window.jamState.progIndex = gridX;
        // Y = octave (top high, bottom low) 
        const octaves = [2, 1.5, 1, 0.5];
        window.jamState.octaveShift = octaves[gridY];
        // Grid cell affects multiple parameters
        window.jamState.filterMod = (gridX + gridY) / 6;  // 0-1 filter intensity
        window.jamState.swingAmount = gridY * 0.1;  // Swing on lower rows
    }
    
    // BPM varies with X (120-145 for driving trance/electro)
    currentBpm = 120 + x * 25;
    
    // Pattern changes with grid X
    currentPatternIndex = gridX * 2;  // 8 patterns across 4 columns
    
    if (!audioCtx) {
        initAudio(e);
    }
    
    if (triggerGlitch) triggerClickGlitch();
}

function initAudio(e) {
    const hint = document.getElementById('sound-hint');
    if (hint) hint.style.display = 'none';
    
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AudioContext();
    
    // Resume synchronously (required for iOS in user gesture)
    if (audioCtx.state === 'suspended') {
        audioCtx.resume();
    }
    
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.3;
    masterGain.connect(audioCtx.destination);
    
    // C64 SID-style 8-bit synth
    const chord = minorChords[Math.floor(Math.random() * minorChords.length)];
    
    // Simple delay for space - longer for synthwave atmosphere
    const delay = audioCtx.createDelay(0.8);
    delay.delayTime.value = 0.4;
    const delayGain = audioCtx.createGain();
    delayGain.gain.value = 0.35;
    delay.connect(delayGain);
    delayGain.connect(masterGain);
    
    // SID arpeggiator state
    let arpIndex = 0;
    let arpTime = audioCtx.currentTime;
    
    // Dark synthwave progression - all minor chords, lower register
    const tranceProgression = [
        [73.42, 87.31, 110.00],   // D minor (one octave lower)
        [65.41, 77.78, 92.50],    // C minor (dark)
        [61.74, 73.42, 87.31],    // B minor (brooding)
        [55.00, 65.41, 82.41],    // A minor (melancholic)
    ];
    
    // Touch control state (exposed globally)
    window.jamState = {
        progIndex: 0,      // X controls chord in progression
        octaveShift: 1,    // Y controls octave (0.5, 1, 2)
    };
    
    // Bass - pulse wave (SID's classic sound)
    const bassOsc = audioCtx.createOscillator();
    bassOsc.type = 'sawtooth';  // SID sawtooth
    bassOsc.frequency.value = chord[0];
    const bassGain = audioCtx.createGain();
    bassGain.gain.value = 0.04;
    bassOsc.connect(bassGain);
    bassGain.connect(masterGain);
    bassOsc.start();
    oscillators.push(bassOsc);
    
    // Chord voices - mixed waveforms like real SID
    const chordGain = audioCtx.createGain();
    chordGain.gain.value = 0.05;
    chordGain.connect(masterGain);
    chordGain.connect(delay);
    
    const triangleGain = audioCtx.createGain();
    triangleGain.gain.value = 0;  // Controlled by pattern
    triangleGain.connect(masterGain);
    triangleGain.connect(delay);
    
    const chordOscs = [];
    // SID has 3 voices: use pulse/saw/triangle mix
    const sidWaveforms = ['sawtooth', 'square', 'triangle'];
    for (let i = 0; i < 3; i++) {
        const osc = audioCtx.createOscillator();
        osc.type = sidWaveforms[i];  // Mixed waveforms like SID
        osc.frequency.value = chord[i];
        if (i === 2) {
            osc.connect(triangleGain);
        } else {
            osc.connect(chordGain);
        }
        osc.start();
        oscillators.push(osc);
        chordOscs.push(osc);
    }
    
    // Lead - pure square wave (classic SID lead)
    const leadOsc = audioCtx.createOscillator();
    leadOsc.type = 'square';
    leadOsc.frequency.value = chord[0] * 2;
    const leadGain = audioCtx.createGain();
    leadGain.gain.value = 0;
    leadOsc.connect(leadGain);
    leadGain.connect(masterGain);
    leadGain.connect(delay);
    leadOsc.start();
    oscillators.push(leadOsc);
    
    // Second lead - square one octave up for that piercing SID sound
    const leadOsc2 = audioCtx.createOscillator();
    leadOsc2.type = 'square';
    leadOsc2.frequency.value = chord[0] * 4;  // Octave up
    const leadGain2 = audioCtx.createGain();
    leadGain2.gain.value = 0;
    leadOsc2.connect(leadGain2);
    leadGain2.connect(masterGain);
    leadOsc2.start();
    oscillators.push(leadOsc2);
    
    // Sub bass - triangle (SID triangle is very pure) - deeper for synthwave
    const subOsc = audioCtx.createOscillator();
    subOsc.type = 'triangle';
    subOsc.frequency.value = chord[0] / 4;  // Two octaves below for deep bass
    const subGain = audioCtx.createGain();
    subGain.gain.value = 0.1;  // Louder sub for that synthwave weight
    subOsc.connect(subGain);
    subGain.connect(masterGain);
    subOsc.start();
    oscillators.push(subOsc);
    
    // 8-bit drums
    // Kick - triangle wave with pitch envelope (SID style)
    const kickOsc = audioCtx.createOscillator();
    kickOsc.type = 'triangle';
    kickOsc.frequency.value = 40;
    const kickGain = audioCtx.createGain();
    kickGain.gain.value = 0;
    kickOsc.connect(kickGain);
    kickGain.connect(masterGain);
    kickOsc.start();
    oscillators.push(kickOsc);
    
    // Snare/Hat - noise source
    const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.5, audioCtx.sampleRate);
    const noiseData = noiseBuffer.getChannelData(0);
    for (let i = 0; i < noiseData.length; i++) {
        noiseData[i] = Math.random() * 2 - 1;
    }
    
    const snareNoise = audioCtx.createBufferSource();
    snareNoise.buffer = noiseBuffer;
    snareNoise.loop = true;
    const snareFilter = audioCtx.createBiquadFilter();
    snareFilter.type = 'bandpass';
    snareFilter.frequency.value = 3000;
    snareFilter.Q.value = 1;
    const snareGain = audioCtx.createGain();
    snareGain.gain.value = 0;
    snareNoise.connect(snareFilter);
    snareFilter.connect(snareGain);
    snareGain.connect(masterGain);
    snareNoise.start();
    
    const hatNoise = audioCtx.createBufferSource();
    hatNoise.buffer = noiseBuffer;
    hatNoise.loop = true;
    const hatFilter = audioCtx.createBiquadFilter();
    hatFilter.type = 'highpass';
    hatFilter.frequency.value = 8000;
    const hatGain = audioCtx.createGain();
    hatGain.gain.value = 0;
    hatNoise.connect(hatFilter);
    hatFilter.connect(hatGain);
    hatGain.connect(masterGain);
    hatNoise.start();
    
    // 8-bit arpeggiator with touch control
    function scheduleArp() {
        if (!audioCtx) return;
        
        const baseSpeed = 60 / currentBpm / 4;
        const now = audioCtx.currentTime;
        
        // Only schedule if we're not too far ahead - prevents automation buildup
        if (arpTime > now + 0.2) {
            setTimeout(scheduleArp, 50);
            return;
        }
        
        while (arpTime < now + 0.1) {
            const pattern = gatePatterns[currentPatternIndex % gatePatterns.length];
            const step = arpIndex % 16;
            
            // No swing - straight electro/trance timing
            const swing = 0;
            const speed = baseSpeed;
            
            // Use touch-controlled chord from progression
            const progChord = tranceProgression[window.jamState.progIndex % 4];
            const octave = window.jamState.octaveShift;
            
            // Update chord frequencies - one octave down
            for (let i = 0; i < 3; i++) {
                chordOscs[i].frequency.setValueAtTime(progChord[i] * octave, arpTime + swing);
            }
            
            // Chord gate pattern - use pattern based on grid position
            const padPatternIdx = (currentPatternIndex + 3) % gatePatterns.length;
            const padPattern = gatePatterns[padPatternIdx];
            const chordAccent = padPattern[step];
            chordGain.gain.cancelScheduledValues(arpTime);
            if (chordAccent > 0.1) {
                chordGain.gain.setValueAtTime(0.07 * chordAccent, arpTime);
                chordGain.gain.exponentialRampToValueAtTime(0.015, arpTime + speed * 0.7);
            } else {
                chordGain.gain.setValueAtTime(0.015, arpTime);
            }
            
            // Triangle pattern - offbeat rhythmic stabs
            const triPatternIdx = (currentPatternIndex + 5) % gatePatterns.length;
            const triPattern = gatePatterns[triPatternIdx];
            const triAccent = triPattern[step];
            triangleGain.gain.cancelScheduledValues(arpTime);
            if (triAccent > 0.5) {
                triangleGain.gain.setValueAtTime(0.1, arpTime);
                triangleGain.gain.exponentialRampToValueAtTime(0.01, arpTime + speed * 0.6);
            } else if (triAccent > 0.2) {
                triangleGain.gain.setValueAtTime(0.05, arpTime);
                triangleGain.gain.exponentialRampToValueAtTime(0.01, arpTime + speed * 0.4);
            }
            
            // Bass pattern - 8th note pulse with octave jumps
            bassOsc.frequency.setValueAtTime(progChord[0] * octave * 0.25, arpTime);
            const bassPattern = [1, 0, 0.7, 0, 1, 0.5, 0, 0.8, 1, 0, 0.6, 0, 1, 0, 0.7, 0.5];
            const bassAccent = bassPattern[step];
            bassGain.gain.cancelScheduledValues(arpTime);
            if (bassAccent > 0.5) {
                bassGain.gain.setValueAtTime(0.05, arpTime + swing);
                bassGain.gain.exponentialRampToValueAtTime(0.01, arpTime + swing + speed * 0.8);
            } else if (bassAccent > 0.3) {
                bassGain.gain.setValueAtTime(0.03, arpTime + swing);
                bassGain.gain.exponentialRampToValueAtTime(0.005, arpTime + swing + speed * 0.5);
            } else {
                bassGain.gain.setValueAtTime(0.005, arpTime + swing);
            }
            
            // 4 arp patterns - driving trance/electro style
            const arpPatternIdx = currentPatternIndex % 4;
            const arpPatterns = [
                [0, 1, 2, 1, 0, 1, 2, 1],  // 0: Classic trance up-down
                [0, 0, 1, 1, 2, 2, 1, 0],  // 1: Building wave
                [0, 2, 0, 2, 0, 2, 1, 2],  // 2: Driving octave
                [0, 1, 2, 0, 1, 2, 0, 2],  // 3: Ascending run
            ];
            const octavePatterns = [
                [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1],  // Steady pulse
                [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0],  // Accent highs
                [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],  // Alternating
                [0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0],  // Build up
            ];
            
            const noteIdx = arpPatterns[arpPatternIdx][step % 8];
            const arpOctave = octavePatterns[arpPatternIdx][step];
            const accent = pattern[step];
            
            // Update lead intensity for glow sync
            leadIntensity = accent;
            
            const leadFreq = progChord[noteIdx] * 2 * octave * (arpOctave ? 2 : 1);
            const noteTime = arpTime + swing;  // Apply swing timing
            leadGain.gain.cancelScheduledValues(noteTime);
            leadGain2.gain.cancelScheduledValues(noteTime);
            if (accent > 0.5) {
                leadOsc.frequency.setValueAtTime(leadFreq, noteTime);
                leadOsc2.frequency.setValueAtTime(leadFreq * 2, noteTime);  // Octave up for 8-bit
                leadGain.gain.setValueAtTime(0.12, noteTime);
                leadGain2.gain.setValueAtTime(0.06, noteTime);
                leadGain.gain.exponentialRampToValueAtTime(0.01, noteTime + speed * 0.5);
                leadGain2.gain.exponentialRampToValueAtTime(0.01, noteTime + speed * 0.4);
            } else if (accent > 0.2) {
                leadOsc.frequency.setValueAtTime(progChord[noteIdx] * 2 * octave, noteTime);
                leadOsc2.frequency.setValueAtTime(progChord[noteIdx] * 4 * octave, noteTime);
                leadGain.gain.setValueAtTime(0.06, noteTime);
                leadGain2.gain.setValueAtTime(0.03, noteTime);
                leadGain.gain.exponentialRampToValueAtTime(0.01, noteTime + speed * 0.3);
                leadGain2.gain.exponentialRampToValueAtTime(0.01, noteTime + speed * 0.25);
            }
            
            // Sub bass follows root with swing
            subOsc.frequency.setValueAtTime(progChord[0] / 2 * octave, noteTime);
            
            // 8-bit drums - kick on 1 and 9, snare on 5 and 13, hats on others
            // Drums come in after 32 steps (2 bars)
            if (arpIndex > 32) {
                const drumVol = Math.min(1, (arpIndex - 32) / 32);  // Fade in
                
                if (step === 0 || step === 8) {
                    // Kick - low square pitch drop
                    kickOsc.frequency.setValueAtTime(150, arpTime);
                    kickOsc.frequency.exponentialRampToValueAtTime(40, arpTime + 0.1);
                    kickGain.gain.setValueAtTime(0.15 * drumVol, arpTime);
                    kickGain.gain.exponentialRampToValueAtTime(0.001, arpTime + 0.15);
                }
                
                // Varied drum patterns based on current pattern
                const drumPatternIdx = currentPatternIndex % 4;
                const kickPatterns = [
                    [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0],  // Four on floor
                    [1,0,0,0, 0,0,1,0, 0,0,1,0, 0,0,0,0],  // Breakbeat
                    [1,0,0,1, 0,0,1,0, 1,0,0,0, 1,0,1,0],  // Syncopated
                    [1,0,1,0, 0,0,1,0, 1,0,0,1, 0,0,1,0],  // Busy
                ];
                const snarePatterns = [
                    [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],  // Backbeat
                    [0,0,0,0, 1,0,0,1, 0,0,0,0, 1,0,1,0],  // Fills
                    [0,0,1,0, 0,0,0,0, 0,0,1,0, 0,0,0,1],  // Offbeat
                    [0,0,0,0, 1,0,0,0, 0,1,0,0, 1,0,0,0],  // Shuffle
                ];
                const hatPatterns = [
                    [1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0],  // 8ths
                    [1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1],  // 16ths
                    [1,0,1,1, 1,0,1,1, 1,0,1,1, 1,0,1,1],  // Gallop
                    [1,0,0,1, 1,0,0,1, 1,0,0,1, 1,0,1,0],  // Synth pop
                ];
                
                if (kickPatterns[drumPatternIdx][step]) {
                    kickGain.gain.cancelScheduledValues(arpTime);
                    kickOsc.frequency.setValueAtTime(150, arpTime);
                    kickOsc.frequency.exponentialRampToValueAtTime(40, arpTime + 0.1);
                    kickGain.gain.setValueAtTime(0.12 * drumVol, arpTime);
                    kickGain.gain.exponentialRampToValueAtTime(0.001, arpTime + 0.15);
                }
                
                if (snarePatterns[drumPatternIdx][step]) {
                    // Snare - noise burst
                    snareGain.gain.cancelScheduledValues(arpTime);
                    snareGain.gain.setValueAtTime(0.1 * drumVol, arpTime);
                    snareGain.gain.exponentialRampToValueAtTime(0.001, arpTime + 0.1);
                }
                
                if (hatPatterns[drumPatternIdx][step]) {
                    // Hi-hat - high freq noise, velocity based on pattern
                    hatGain.gain.cancelScheduledValues(arpTime);
                    const hatVel = (step % 4 === 0) ? 0.05 : 0.03;
                    hatGain.gain.setValueAtTime(hatVel * drumVol, arpTime);
                    hatGain.gain.exponentialRampToValueAtTime(0.001, arpTime + 0.05);
                }
            }
            
            arpIndex++;
            arpTime += speed;
        }
        setTimeout(scheduleArp, 40);
    }
    scheduleArp();
    
    // Show that audio started
    if (hint) {
        hint.textContent = 'Audio playing';
        setTimeout(() => { hint.style.opacity = '0'; }, 1000);
    }
}

function triggerGlitchSound() {}

let lastChordIndex = -1;

function changeChord(chordIndex) {
    if (!audioCtx || chordOscillators.length === 0) return;
    if (chordIndex === lastChordIndex) return;
    lastChordIndex = chordIndex;
    
    // For C64 style - just update bass, arpeggiator handles the rest
    const chord = minorChords[Math.min(chordIndex, minorChords.length - 1)];
    const now = audioCtx.currentTime;
    
    // Bass is first oscillator
    if (chordOscillators[0]) {
        chordOscillators[0].frequency.setTargetAtTime(chord[0], now, 0.05);
    }
}

// Start audio on user interaction - touchend is most reliable on iOS
document.addEventListener('click', (e) => handleInteraction(e, true));
document.addEventListener('touchend', (e) => {
    e.preventDefault();
    isTouching = false;  // Release
    // Call handleInteraction but don't update touchPos or isTouching (false flag)
    handleInteraction(e, true, false);
});
document.addEventListener('touchstart', (e) => {
    isTouching = true;
    let x = e.touches[0].clientX / window.innerWidth;
    let y = e.touches[0].clientY / window.innerHeight;
    touchPos.x = x;
    touchPos.y = y;
    // Snap smoothTouchPos to new position immediately
    smoothTouchPos.x = x;
    smoothTouchPos.y = y;
    
    // Same grid controls as touchmove
    const gridX = Math.floor(x * 4);
    const gridY = Math.floor(y * 4);
    const cellIndex = gridX + gridY * 4;
    if (window.jamState) {
        window.jamState.progIndex = gridX;
        const octaves = [2, 1.5, 1, 0.5];
        const newOctave = octaves[gridY];
        if (newOctave !== window.jamState.octaveShift) {
            beatGlitch = 1.0;
        }
        window.jamState.octaveShift = newOctave;
    }
    currentPatternIndex = gridX;  // Same pattern for each column
    clickGlitch = 0.8;
});
document.addEventListener('mousedown', (e) => {
    isTouching = true;
    let x = e.clientX / window.innerWidth;
    let y = e.clientY / window.innerHeight;
    touchPos.x = x;
    touchPos.y = y;
    // Snap smoothTouchPos to new position immediately
    smoothTouchPos.x = x;
    smoothTouchPos.y = y;
    
    // Same grid controls as mousemove
    const gridX = Math.floor(x * 4);
    const gridY = Math.floor(y * 4);
    const cellIndex = gridX + gridY * 4;
    if (window.jamState) {
        window.jamState.progIndex = gridX;
        const octaves = [2, 1.5, 1, 0.5];
        const newOctave = octaves[gridY];
        if (newOctave !== window.jamState.octaveShift) {
            beatGlitch = 1.0;
        }
        window.jamState.octaveShift = newOctave;
    }
    currentPatternIndex = gridX;  // Same pattern for each column
    clickGlitch = 0.8;
});
document.addEventListener('mouseup', () => {
    isTouching = false;
    // Keep last touchPos - don't reset! u_touching fades pyramid to up
});
document.addEventListener('mousemove', (e) => {
    if (isTouching) {
        touchPos.x = e.clientX / window.innerWidth;
        touchPos.y = e.clientY / window.innerHeight;
    }
});
document.addEventListener('touchmove', (e) => {
    e.preventDefault();
    let x = 0.5, y = 0.5;
    if (e.touches && e.touches[0]) {
        x = e.touches[0].clientX / window.innerWidth;
        y = e.touches[0].clientY / window.innerHeight;
    }
    
    // Update touch position for pyramid
    touchPos.x = x;
    touchPos.y = y;
    
    // 4x4 grid glitch on cell change
    const gridX = Math.floor(x * 4);
    const gridY = Math.floor(y * 4);
    const cellIndex = gridX + gridY * 4;  // 0-15 unique per cell
    const newGlitchMode = cellIndex;
    if (newGlitchMode !== glitchMode) {
        glitchMode = newGlitchMode;
    }
    
    // Jam controls - real-time updates
    if (window.jamState) {
        window.jamState.progIndex = gridX;
        const octaves = [2, 1.5, 1, 0.5];
        const newOctave = octaves[gridY];
        // Glitch only on octave change
        if (newOctave !== window.jamState.octaveShift) {
            beatGlitch = 1.0;
        }
        window.jamState.octaveShift = newOctave;
        window.jamState.filterMod = (gridX + gridY) / 6;
        window.jamState.swingAmount = gridY * 0.1;
    }
    // Same arp pattern for each column
    currentPatternIndex = gridX;
}, { passive: false });

const startTime = performance.now() / 1000;
let lastGlitchState = false;

function fract(x) {
    return x - Math.floor(x);
}

let lastPyramidGlitchState = false;

function render() {
    const t = performance.now() / 1000 - startTime;
    const aspect = w / h;
    // Flicker synced to lead pattern intensity
    const flicker = 0.7 + 0.3 * leadIntensity;
    const scale = 0.55 + 0.03 * Math.cos(t);
    
    // Check for logo glitch timing (sync with shader)
    const timeSeed = Math.floor(t * 0.15);
    const intervalRand = fract(Math.sin(timeSeed * 127.1) * 43758.5);
    const interval = 5.0 + intervalRand * 6.0;
    const flickerPhase = t % interval;
    const flickerDuration = 0.12 + intervalRand * 0.15;
    const glitchActive = flickerPhase > (interval - flickerDuration);
    
    // Check for pyramid RGB split timing (sync with shader)
    const pyramidGlitchSeed = Math.floor(t * 0.2);
    const pyramidGlitchRand = fract(Math.sin(pyramidGlitchSeed * 78.233) * 43758.5);
    const pyramidGlitchPhase = fract(t * 0.2);
    const pyramidGlitchActive = pyramidGlitchPhase > 0.92 && pyramidGlitchRand > 0.6;
    
    // Trigger sound on logo glitch
    if (glitchActive && !lastGlitchState) {
        triggerGlitchSound();
    }
    lastGlitchState = glitchActive;
    
    // Trigger sound on pyramid RGB split
    if (pyramidGlitchActive && !lastPyramidGlitchState) {
        triggerGlitchSound();
    }
    lastPyramidGlitchState = pyramidGlitchActive;
    
    // Update pyramid rotation based on BPM - super slow base
    const now = performance.now() / 1000;
    const deltaTime = lastFrameTime ? (now - lastFrameTime) : 0.016;
    lastFrameTime = now;
    const rotSpeed = 0.02 + (currentBpm - 100) / 60;  // Base 0.02 rad/s (very slow), scales gently with BPM
    pyramidRotation += deltaTime * rotSpeed;
    
    // Render pyramid to FBO
    gl.bindFramebuffer(gl.FRAMEBUFFER, fboOrig);
    gl.viewport(0, 0, blurW, blurH);
    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    
    gl.useProgram(octaProg);
    gl.bindBuffer(gl.ARRAY_BUFFER, pyramidBuffer);
    const aPosOcta = gl.getAttribLocation(octaProg, 'a_pos');
    gl.enableVertexAttribArray(aPosOcta);
    gl.vertexAttribPointer(aPosOcta, 3, gl.FLOAT, false, 0, 0);
    gl.uniform1f(gl.getUniformLocation(octaProg, 'u_time'), t);
    gl.uniform1f(gl.getUniformLocation(octaProg, 'u_aspect'), aspect);
    gl.uniform1f(gl.getUniformLocation(octaProg, 'u_scale'), scale);
    gl.uniform1f(gl.getUniformLocation(octaProg, 'u_flicker'), flicker);
    gl.uniform1f(gl.getUniformLocation(octaProg, 'u_rotation'), pyramidRotation);
    
    // Smooth the touching state for camera tilt
    const targetTouching = isTouching ? 1.0 : 0.0;
    smoothTouching += (targetTouching - smoothTouching) * 0.12;
    if (smoothTouching < 0.01) smoothTouching = 0;
    gl.uniform1f(gl.getUniformLocation(octaProg, 'u_touching'), smoothTouching);
    
    // Only update smoothTouchPos while touching - FREEZE on release
    // u_touching fades to 0, which makes mix(baseP, tiltedP, 0) = baseP (pointing up)
    // Don't lerp toward center - that causes pyramid to go through "facing camera" position
    if (isTouching) {
        smoothTouchPos.x += (touchPos.x - smoothTouchPos.x) * 0.1;
        smoothTouchPos.y += (touchPos.y - smoothTouchPos.y) * 0.1;
    }
    // Frozen smoothTouchPos + fading u_touching = smooth return to up
    gl.uniform2f(gl.getUniformLocation(octaProg, 'u_touch'), smoothTouchPos.x, smoothTouchPos.y);
    
    gl.lineWidth(2);
    gl.drawArrays(gl.LINES, 0, pyramidVertices.length / 3);
    
    // Blur passes
    gl.useProgram(blurProg);
    gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
    const aPosBlur = gl.getAttribLocation(blurProg, 'a_pos');
    gl.enableVertexAttribArray(aPosBlur);
    gl.vertexAttribPointer(aPosBlur, 2, gl.FLOAT, false, 0, 0);
    gl.uniform2f(gl.getUniformLocation(blurProg, 'u_res'), blurW, blurH);
    
    // Pass 1: horiz
    gl.bindFramebuffer(gl.FRAMEBUFFER, fboBlur1);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texOrig);
    gl.uniform1i(gl.getUniformLocation(blurProg, 'u_tex'), 0);
    gl.uniform2f(gl.getUniformLocation(blurProg, 'u_dir'), 2, 0);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    
    // Pass 2: vert
    gl.bindFramebuffer(gl.FRAMEBUFFER, fboBlur2);
    gl.bindTexture(gl.TEXTURE_2D, texBlur1);
    gl.uniform2f(gl.getUniformLocation(blurProg, 'u_dir'), 0, 2);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    
    // Pass 3: horiz wider
    gl.bindFramebuffer(gl.FRAMEBUFFER, fboBlur1);
    gl.bindTexture(gl.TEXTURE_2D, texBlur2);
    gl.uniform2f(gl.getUniformLocation(blurProg, 'u_dir'), 3, 0);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    
    // Pass 4: vert wider
    gl.bindFramebuffer(gl.FRAMEBUFFER, fboBlur2);
    gl.bindTexture(gl.TEXTURE_2D, texBlur1);
    gl.uniform2f(gl.getUniformLocation(blurProg, 'u_dir'), 0, 3);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    
    // Composite to screen
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, w, h);
    
    gl.useProgram(compProg);
    gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
    const aPosComp = gl.getAttribLocation(compProg, 'a_pos');
    gl.enableVertexAttribArray(aPosComp);
    gl.vertexAttribPointer(aPosComp, 2, gl.FLOAT, false, 0, 0);
    
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texOrig);
    gl.uniform1i(gl.getUniformLocation(compProg, 'u_orig'), 0);
    
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, texBlur2);
    gl.uniform1i(gl.getUniformLocation(compProg, 'u_blur'), 1);
    
    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, logoTex);
    gl.uniform1i(gl.getUniformLocation(compProg, 'u_logo'), 2);
    
    gl.activeTexture(gl.TEXTURE3);
    gl.bindTexture(gl.TEXTURE_2D, bgTex);
    gl.uniform1i(gl.getUniformLocation(compProg, 'u_bg'), 3);
    
    gl.uniform1f(gl.getUniformLocation(compProg, 'u_time'), t);
    gl.uniform1f(gl.getUniformLocation(compProg, 'u_aspect'), aspect);
    gl.uniform1f(gl.getUniformLocation(compProg, 'u_logoAspect'), logoAspect);
    gl.uniform1f(gl.getUniformLocation(compProg, 'u_clickGlitch'), clickGlitch);
    gl.uniform1f(gl.getUniformLocation(compProg, 'u_beatGlitch'), beatGlitch);
    gl.uniform1f(gl.getUniformLocation(compProg, 'u_leadIntensity'), leadIntensity);
    gl.uniform2f(gl.getUniformLocation(compProg, 'u_touch'), smoothTouchPos.x, smoothTouchPos.y);
    gl.uniform1f(gl.getUniformLocation(compProg, 'u_touching'), smoothTouching);
    
    // Decay glitches
    clickGlitch *= 0.85;
    if (clickGlitch < 0.01) clickGlitch = 0;
    beatGlitch *= 0.9;
    if (beatGlitch < 0.01) beatGlitch = 0;
    
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    
    requestAnimationFrame(render);
}

render();
    </script>
</body>
</html>
